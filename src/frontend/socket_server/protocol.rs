//! Defines the messages clients and server may exchange through a socket (either textual or binary),
//! as well as serializers & deserializers

use std::fmt::Write;
use lazy_static::lazy_static;
use ron::{
    Options,
    ser::PrettyConfig,
};
use serde::{Serialize, Deserialize};


/// Messages coming from the clients, suitable to be deserialized by this server
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ClientMessages {

    /// Increments a per-client counter, which is answered as an `usize` by [ServerMessage::Pong]
    Ping,

    /// Increments a per-client counter, which is answered as a `String` by [ServerMessage::Pung]
    Pang,

    /// demo request causing the processor to not emit an answer
    Speechless,

    /// demo request causing the processor to result in `Err`
    Error,
}

/// Messages generated by this server, suitable to be serialized here
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ServerMessages {

    /// Response of [ClientMessage::Ping]: increments a per-client counter
    /// and answers the result
    Pong(usize),

    /// Response of [ServerMessage::Pang] -- similar to [ClientMessage::Pong], but answers
    /// in a `String`
    Pung(String),

    /// Common messages to all protocols
    /// ////////////////////////////////

    /// If the processor answers with this message, nothing will be sent back to the client
    None,

    /// Whenever the server don't understand a message, this will be answered, along with the
    /// received message
    UnknownMessage(String),

    /// If the server cannot immediately process the message, or if its queue is full, this will be
    /// answered and the message from the client will be dropped -- clients are advised to try
    /// again, if the deadline didn't come yet
    TooBusy,

    /// If the processor results in `Err`, this will be sent along with the error description
    ProcessorError(String),

    /// Server sends this to connected clients once it has decided it is time to quit
    ShuttingDown,
}


// RON SERDE
////////////

lazy_static! {

    static ref RON_EXTENSIONS: ron::extensions::Extensions = {
        let mut extensions = ron::extensions::Extensions::empty();
        extensions.insert(ron::extensions::Extensions::IMPLICIT_SOME);
        extensions.insert(ron::extensions::Extensions::UNWRAP_NEWTYPES);
        extensions.insert(ron::extensions::Extensions::UNWRAP_VARIANT_NEWTYPES);
        extensions
    };

    static ref RON_SERIALIZER_CONFIG: PrettyConfig = ron::ser::PrettyConfig::new()
        .depth_limit(10)
        .new_line(String::from(""))
        .indentor(String::from(""))
        .separate_tuple_members(true)
        .enumerate_arrays(false)
        .extensions(*RON_EXTENSIONS);

    static ref RON_DESERIALIZER_CONFIG: Options = ron::Options::default()
        ;//.with_default_extension(*RON_EXTENSIONS);

}

/// RON serializer for server messages
pub fn ron_serializer(message: ServerMessages) -> String {
    let mut output_data = ron::ser::to_string(&message).unwrap();
    write!(output_data, "\n").unwrap();
    output_data
}

/// RON deserializer for client messages
pub fn ron_deserializer(message: &[u8]) -> Result<ClientMessages, Box<dyn std::error::Error>> {
    RON_DESERIALIZER_CONFIG.from_bytes(message)
        .map_err(|err| Box::from(format!("RON deserialization error for message '{:?}': {}", std::str::from_utf8(message), err)))
}


/// Unit tests the [protocol](self) module
#[cfg(any(test, feature = "dox"))]
mod tests {
    use super::*;

    /// assures RON serialization / deserialization works for the server & produces good human readable/writeable text
    #[test]
    fn ron_serde_for_server_only() {
        let message = ServerMessages::UnknownMessage(String::from("This is an error message"));
        let expected = "UnknownMessage(\"This is an error message\")\n";
        let observed = ron_serializer(message);
        assert_eq!(observed, expected, "RON serialization is not good");

        let message = "Ping".as_bytes();
        let expected = ClientMessages::Ping;
        let observed = ron_deserializer(message)
            .expect("RON deserialization failed");
        assert_eq!(observed, expected, "RON deserialization is not good");
    }
}